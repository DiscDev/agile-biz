const BaseAgentHook = require('../../shared/base-agent-hook');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);
const fs = require('fs-extra');
const path = require('path');

/**
 * Vulnerability Scanner Hook
 * Scans project dependencies for known security vulnerabilities
 * Uses npm audit, yarn audit, or other security tools
 */
class VulnerabilityScanner extends BaseAgentHook {
  constructor(config = {}) {
    super({
      name: 'vulnerability-scanner',
      agent: 'security_agent',
      category: 'critical',
      impact: 'low', // Fast scan using cached data
      cacheEnabled: true,
      cacheTTL: 3600000, // 1 hour cache
      ...config
    });

    this.severityThresholds = {
      critical: config.config?.thresholds?.critical ?? 0,
      high: config.config?.thresholds?.high ?? 0,
      moderate: config.config?.thresholds?.moderate ?? 5,
      low: config.config?.thresholds?.low ?? 10
    };

    this.scanners = {
      npm: this.scanNpm.bind(this),
      yarn: this.scanYarn.bind(this),
      pip: this.scanPip.bind(this),
      composer: this.scanComposer.bind(this)
    };
  }

  async handle(context) {
    const { projectPath, fileType, action } = context;

    // Only scan on dependency file changes
    if (!this.shouldScan(fileType, action)) {
      return { skipped: true, reason: 'Not a dependency file change' };
    }

    const results = {
      vulnerabilities: [],
      summary: {
        critical: 0,
        high: 0,
        moderate: 0,
        low: 0
      },
      scanners: []
    };

    // Detect project type and run appropriate scanners
    const projectTypes = await this.detectProjectTypes(projectPath);
    
    for (const type of projectTypes) {
      if (this.scanners[type]) {
        try {
          const scanResult = await this.scanners[type](projectPath);
          results.scanners.push({ type, ...scanResult });
          
          // Aggregate vulnerabilities
          if (scanResult.vulnerabilities) {
            results.vulnerabilities.push(...scanResult.vulnerabilities);
            results.summary.critical += scanResult.summary?.critical || 0;
            results.summary.high += scanResult.summary?.high || 0;
            results.summary.moderate += scanResult.summary?.moderate || 0;
            results.summary.low += scanResult.summary?.low || 0;
          }
        } catch (error) {
          console.error(`[VulnerabilityScanner] ${type} scan failed:`, error.message);
        }
      }
    }

    // Check against thresholds
    const violations = this.checkThresholds(results.summary);
    
    return {
      success: true,
      vulnerabilities: results.vulnerabilities,
      summary: results.summary,
      violations,
      blocked: violations.length > 0,
      message: this.generateMessage(results, violations)
    };
  }

  shouldScan(fileType, action) {
    const dependencyFiles = [
      'package.json',
      'package-lock.json',
      'yarn.lock',
      'requirements.txt',
      'Pipfile',
      'Pipfile.lock',
      'composer.json',
      'composer.lock',
      'Gemfile',
      'Gemfile.lock'
    ];

    return dependencyFiles.some(file => fileType?.includes(file)) && 
           ['created', 'modified'].includes(action);
  }

  async detectProjectTypes(projectPath) {
    const types = [];
    
    if (await fs.pathExists(path.join(projectPath, 'package.json'))) {
      if (await fs.pathExists(path.join(projectPath, 'yarn.lock'))) {
        types.push('yarn');
      } else {
        types.push('npm');
      }
    }
    
    if (await fs.pathExists(path.join(projectPath, 'requirements.txt')) ||
        await fs.pathExists(path.join(projectPath, 'Pipfile'))) {
      types.push('pip');
    }
    
    if (await fs.pathExists(path.join(projectPath, 'composer.json'))) {
      types.push('composer');
    }
    
    return types;
  }

  async scanNpm(projectPath) {
    try {
      // Run npm audit
      const { stdout } = await execAsync('npm audit --json', { 
        cwd: projectPath,
        maxBuffer: 10 * 1024 * 1024 // 10MB buffer
      });
      
      const auditData = JSON.parse(stdout);
      
      return {
        success: true,
        vulnerabilities: this.parseNpmVulnerabilities(auditData),
        summary: {
          critical: auditData.metadata?.vulnerabilities?.critical || 0,
          high: auditData.metadata?.vulnerabilities?.high || 0,
          moderate: auditData.metadata?.vulnerabilities?.moderate || 0,
          low: auditData.metadata?.vulnerabilities?.low || 0
        }
      };
    } catch (error) {
      // npm audit returns non-zero exit code when vulnerabilities found
      if (error.stdout) {
        try {
          const auditData = JSON.parse(error.stdout);
          return {
            success: true,
            vulnerabilities: this.parseNpmVulnerabilities(auditData),
            summary: {
              critical: auditData.metadata?.vulnerabilities?.critical || 0,
              high: auditData.metadata?.vulnerabilities?.high || 0,
              moderate: auditData.metadata?.vulnerabilities?.moderate || 0,
              low: auditData.metadata?.vulnerabilities?.low || 0
            }
          };
        } catch (parseError) {
          throw error;
        }
      }
      throw error;
    }
  }

  parseNpmVulnerabilities(auditData) {
    const vulnerabilities = [];
    
    if (auditData.advisories) {
      Object.values(auditData.advisories).forEach(advisory => {
        vulnerabilities.push({
          id: advisory.id,
          title: advisory.title,
          module: advisory.module_name,
          severity: advisory.severity,
          description: advisory.overview,
          recommendation: advisory.recommendation,
          url: advisory.url
        });
      });
    }
    
    return vulnerabilities;
  }

  async scanYarn(projectPath) {
    try {
      const { stdout } = await execAsync('yarn audit --json', { 
        cwd: projectPath,
        maxBuffer: 10 * 1024 * 1024
      });
      
      // Parse yarn audit output (NDJSON format)
      const lines = stdout.trim().split('\n');
      const auditSummary = JSON.parse(lines[lines.length - 1]);
      
      return {
        success: true,
        vulnerabilities: [], // Would need to parse full output
        summary: {
          critical: auditSummary.data?.vulnerabilities?.critical || 0,
          high: auditSummary.data?.vulnerabilities?.high || 0,
          moderate: auditSummary.data?.vulnerabilities?.moderate || 0,
          low: auditSummary.data?.vulnerabilities?.low || 0
        }
      };
    } catch (error) {
      throw error;
    }
  }

  async scanPip(projectPath) {
    // Would use safety or pip-audit
    return {
      success: false,
      message: 'Python vulnerability scanning not implemented yet'
    };
  }

  async scanComposer(projectPath) {
    // Would use composer audit
    return {
      success: false,
      message: 'PHP vulnerability scanning not implemented yet'
    };
  }

  checkThresholds(summary) {
    const violations = [];
    
    if (summary.critical > this.severityThresholds.critical) {
      violations.push({
        severity: 'critical',
        count: summary.critical,
        threshold: this.severityThresholds.critical
      });
    }
    
    if (summary.high > this.severityThresholds.high) {
      violations.push({
        severity: 'high',
        count: summary.high,
        threshold: this.severityThresholds.high
      });
    }
    
    if (summary.moderate > this.severityThresholds.moderate) {
      violations.push({
        severity: 'moderate',
        count: summary.moderate,
        threshold: this.severityThresholds.moderate
      });
    }
    
    return violations;
  }

  generateMessage(results, violations) {
    if (violations.length === 0) {
      return `âœ… No vulnerability threshold violations found (${results.summary.critical} critical, ${results.summary.high} high)`;
    }
    
    const violationText = violations.map(v => 
      `${v.count} ${v.severity} (threshold: ${v.threshold})`
    ).join(', ');
    
    return `ðŸš¨ Vulnerability thresholds exceeded: ${violationText}`;
  }

  getDescription() {
    return 'Scans project dependencies for known security vulnerabilities';
  }

  getConfigurableOptions() {
    return {
      thresholds: {
        critical: {
          type: 'number',
          default: 0,
          description: 'Maximum allowed critical vulnerabilities'
        },
        high: {
          type: 'number',
          default: 0,
          description: 'Maximum allowed high severity vulnerabilities'
        },
        moderate: {
          type: 'number',
          default: 5,
          description: 'Maximum allowed moderate severity vulnerabilities'
        },
        low: {
          type: 'number',
          default: 10,
          description: 'Maximum allowed low severity vulnerabilities'
        }
      },
      autoFix: {
        type: 'boolean',
        default: false,
        description: 'Automatically run npm/yarn audit fix'
      }
    };
  }
}

module.exports = VulnerabilityScanner;